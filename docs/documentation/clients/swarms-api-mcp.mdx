---
title: 'Swarms API MCP Server'
description: 'Connect MCP-compatible agents and applications to Swarms AI through the Model Context Protocol. Execute agents, orchestrate swarms, run reasoning workflows, and process batches—all via a standardized MCP interface.'
---

## Overview

The Swarms TypeScript MCP Server bridges MCP-compatible agents (Claude Desktop, Cursor IDE, OpenAI Agents, and other MCP clients) with the Swarms AI agent platform. Built with Stainless and following the Model Context Protocol standard, this server exposes Swarms' API endpoints as discoverable tools that agents can invoke directly—enabling agents to execute single agents, orchestrate multi-agent swarms, run reasoning workflows, and process batch operations without custom API integration code.

### Key Capabilities

- **Single Agent Execution**: Run individual Swarms agents with custom tasks, model selection, and configuration parameters
- **Multi-Agent Orchestration**: Coordinate swarms using architectural patterns including sequential workflows, concurrent execution, hierarchical structures, graph-based routing, and majority voting
- **Reasoning Agents**: Execute chain-of-thought reasoning agents for step-by-step problem analysis and complex decision-making
- **Batch Processing**: Process multiple agent tasks or swarm operations in parallel using thread pools for high-throughput workloads
- **Dynamic Discovery**: Use runtime endpoint discovery to explore available API operations, or configure static tool exposure for better performance and type safety
- **Client Optimization**: Automatically adapts tool schemas and capabilities to match your MCP client (Claude Desktop, Cursor IDE, OpenAI Agents, Claude Code, and custom clients)

### Why Use This Server?

The Swarms MCP Server eliminates the need to write custom API integration code when building agent-powered applications. Instead of manually constructing HTTP requests, handling authentication, and parsing responses, agents can directly invoke Swarms operations through standardized MCP tools. The server provides production-ready error handling, rate limit monitoring, health checks, and flexible configuration options—allowing you to expose only the tools your agents need while maintaining full compatibility with the MCP ecosystem.

## Table of Contents

1. [Installation](#installation)
2. [Configuration](#configuration)
3. [Tool Exposure Strategies](#tool-exposure-strategies)
4. [Client Compatibility](#client-compatibility)
5. [Available Tools and Resources](#available-tools-and-resources)
6. [Advanced Usage](#advanced-usage)
7. [Error Handling](#error-handling)
8. [Best Practices](#best-practices)
9. [Client Setup Examples](#client-setup-examples)

## Installation

### Prerequisites

- Node.js (version 14 or higher recommended)
- A valid Swarms API key
- An MCP-compatible client application

### Method 1: Direct Invocation via npx

For quick testing or one-time usage, you can run the MCP server directly without installation:

```bash
export SWARMS_API_KEY="your_api_key_here"
npx -y swarms-ts-mcp@latest
```

### Method 2: Installation via npm

For persistent usage or integration into projects:

```bash
npm install swarms-ts-mcp
```

### Method 3: MCP Client Configuration

Most MCP clients support configuration through a JSON file. Add the following configuration to your client's MCP server settings:

```json
{
  "mcpServers": {
    "swarms_ts_api": {
      "command": "npx",
      "args": ["-y", "swarms-ts-mcp", "--client=claude", "--tools=all"],
      "env": {
        "SWARMS_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

Replace `your_api_key_here` with your actual Swarms API key.

## Configuration

### Environment Variables

The server requires the following environment variable:

- `SWARMS_API_KEY`: Your Swarms platform API key (required)

### Command-Line Arguments

The MCP server supports extensive command-line configuration:

#### Tool Selection

- `--tools=all`: Expose all available tools
- `--tools=dynamic`: Enable dynamic tool discovery mode
- `--tool=<name>`: Include a specific tool by name
- `--no-tool=<name>`: Exclude a specific tool by name

#### Resource Filtering

- `--resource=<name>`: Include all tools under a specific resource
- `--resource=<pattern>*`: Include resources matching a wildcard pattern
- `--no-resource=<name>`: Exclude a specific resource

#### Operation Filtering

- `--operation=read`: Include only read operations (GET/LIST)
- `--operation=write`: Include only write operations (POST/PUT/DELETE)

#### Client Configuration

- `--client=<type>`: Configure for a specific MCP client
  - Valid values: `openai-agents`, `claude`, `claude-code`, `cursor`

#### Capability Settings

- `--capability=<name>`: Enable specific client capabilities
  - `top-level-unions`: Support for top-level union types
  - `valid-json`: JSON string parsing for arguments
  - `refs`: Support for $ref pointers in schemas
  - `unions`: Support for union types (anyOf)
  - `formats`: Support for format validations
  - `tool-name-length=N`: Maximum tool name length

#### Utility Commands

- `--list`: Display all available tools
- `--help`: Show help information

### Configuration Examples

**Filter for read-only operations on a specific resource:**
```bash
npx swarms-ts-mcp --resource=agent --operation=read
```

**Exclude specific tools while including others:**
```bash
npx swarms-ts-mcp --resource=swarms --no-tool=run_swarms_batch
```

**Configure for Cursor with custom capabilities:**
```bash
npx swarms-ts-mcp --client=cursor --capability=tool-name-length=40
```

**Complex multi-criteria filtering:**
```bash
npx swarms-ts-mcp --resource=agent,swarms --operation=read --no-tool=get_logs_swarms
```

## Tool Exposure Strategies

The Swarms MCP server offers two primary strategies for exposing API endpoints as tools:

### Static Tool Exposure

In this mode, each API endpoint is exposed as a dedicated tool with a fully-defined schema. This approach provides:

- Better autocomplete and type safety in client applications
- More accurate parameter validation
- Clearer documentation for each endpoint
- Optimal performance for smaller API surfaces

**Recommendation:** Use static exposure when working with a focused subset of the API or when the client has sufficient context window capacity.

### Dynamic Tool Discovery

When configured with `--tools=dynamic`, the server exposes three meta-tools that enable runtime endpoint discovery:

#### `list_api_endpoints`
Discovers available endpoints with optional search filtering.

**Parameters:**
- `search` (optional): Query string to filter endpoints

**Use case:** Finding relevant endpoints without loading all schemas into context.

#### `get_api_endpoint_schema`
Retrieves detailed schema information for a specific endpoint.

**Parameters:**
- `endpoint`: The name or identifier of the endpoint

**Use case:** Obtaining parameter requirements before invoking an endpoint.

#### `invoke_api_endpoint`
Executes any endpoint with appropriate parameters.

**Parameters:**
- `endpoint`: The endpoint to invoke
- `parameters`: JSON object containing endpoint-specific parameters

**Use case:** Making API calls after discovering and understanding the schema.

**Recommendation:** Use dynamic tools when:
- Working with a large API surface
- Context window limitations are a concern
- Runtime endpoint discovery is required
- The full API schema exceeds available context

### Hybrid Approach

You can combine both strategies by specifying explicit tools alongside dynamic tools:

```bash
npx swarms-ts-mcp --tool=run_agent --tools=dynamic
```

This provides immediate access to frequently-used tools while maintaining the flexibility of dynamic discovery.

## Client Compatibility

Different MCP clients have varying capabilities for handling tool schemas and complex types. The Swarms MCP server automatically adapts its output based on the specified client.

### Supported Clients

#### Claude (`--client=claude`)
Optimized for Claude AI assistant with full schema support.

#### Claude Code (`--client=claude-code`)
Configured for the Claude Code command-line environment.

#### Cursor (`--client=cursor`)
Adapted for the Cursor IDE with appropriate schema simplifications.

#### OpenAI Agents (`--client=openai-agents`)
Compatible with OpenAI's agent framework.

### Manual Capability Configuration

For clients not listed above or to override defaults:

```bash
npx swarms-ts-mcp --capability=top-level-unions,refs,unions,formats,tool-name-length=50
```

Available capabilities:

- `top-level-unions`: Enables union types at the schema root
- `valid-json`: Enables JSON string parsing for complex arguments
- `refs`: Enables JSON Schema $ref pointers
- `unions`: Enables anyOf union types
- `formats`: Enables format validators (date-time, email, etc.)
- `tool-name-length=N`: Sets maximum tool name length

## Available Tools and Resources

### Complete Tools Reference Table

| Tool Name | Resource | Operation Type | Description | Primary Use Case |
|-----------|----------|----------------|-------------|------------------|
| `get_root_client` | $client | Read | Root client information | API connectivity verification and health checks |
| `check_health` | health | Read | Health status of the Swarms API | Monitoring API uptime and status |
| `run_agent` | agent | Write | Execute a single agent with a specified task | Running individual AI agents for specific tasks |
| `run_agent_batch` | agent.batch | Write | Execute multiple agents concurrently using thread pool | Parallel processing of multiple independent agent tasks |
| `list_available_models` | models | Read | Retrieve all available AI models | Model discovery and selection for agent configuration |
| `check_available_swarms` | swarms | Read | Query available swarm types and configurations | Determining which swarm architecture to use |
| `get_logs_swarms` | swarms | Read | Retrieve API request logs for associated API keys | Auditing, debugging, and usage analysis |
| `run_swarms` | swarms | Write | Execute a swarm with a specified task | Orchestrating multiple agents in coordinated patterns |
| `run_swarms_batch` | swarms.batch | Write | Execute multiple swarms concurrently using thread pool | Large-scale parallel swarm processing |
| `create_completion_reasoning_agents` | reasoning_agents | Write | Execute a reasoning agent with chain-of-thought | Complex problem-solving requiring step-by-step analysis |
| `list_types_reasoning_agents` | reasoning_agents | Read | List available reasoning agent types | Selecting appropriate reasoning strategies |
| `get_limits_client_rate` | client.rate | Read | Query rate limits and current usage statistics | Monitoring API quota and preventing rate limit violations |

### Dynamic Discovery Tools

When using `--tools=dynamic`, these additional meta-tools become available:

| Tool Name | Description | Parameters |
|-----------|-------------|------------|
| `list_api_endpoints` | Discover available endpoints with optional filtering | `search` (optional): Query string to filter endpoints |
| `get_api_endpoint_schema` | Retrieve detailed schema for a specific endpoint | `endpoint`: Endpoint name or identifier |
| `invoke_api_endpoint` | Execute any endpoint with appropriate parameters | `endpoint`: Endpoint to invoke<br />`parameters`: JSON object with endpoint-specific parameters |

### Resource: $client

**get_root_client** (read)
- Description: Root client information
- Use case: Health checks and API connectivity verification

### Resource: health

**check_health** (read)
- Description: Health status of the Swarms API
- Returns: API health metrics and status
- Use case: Monitoring and uptime verification

### Resource: agent

**run_agent** (write)
- Description: Execute a single agent with a specified task
- Parameters:
  - `task`: The task description for the agent
  - Additional agent configuration parameters
- Returns: Agent execution results
- Use case: Running individual AI agents for specific tasks

### Resource: agent.batch

**run_agent_batch** (write)
- Description: Execute multiple agents concurrently using a thread pool
- Parameters:
  - `tasks`: Array of task descriptions
  - Batch configuration options
- Returns: Aggregated results from all agents
- Use case: Parallel processing of multiple independent tasks

### Resource: models

**list_available_models** (read)
- Description: Retrieve all available AI models
- Returns: List of model identifiers and capabilities
- Use case: Model discovery and selection

### Resource: swarms

**check_available_swarms** (read)
- Description: Query available swarm types and configurations
- Returns: List of swarm architectures and their capabilities
- Use case: Determining which swarm pattern to use

**get_logs_swarms** (read)
- Description: Retrieve API request logs for all associated API keys
- Returns: Log entries (excluding client IP information)
- Use case: Auditing, debugging, and usage analysis

**run_swarms** (write)
- Description: Execute a swarm with a specified task
- Parameters:
  - `task`: The task for the swarm to execute
  - `swarm_type`: The type of swarm architecture
  - Additional swarm configuration
- Returns: Swarm execution results
- Use case: Orchestrating multiple agents in coordinated patterns

### Resource: swarms.batch

**run_swarms_batch** (write)
- Description: Execute multiple swarms concurrently using a thread pool
- Parameters:
  - `tasks`: Array of swarm tasks
  - Batch and swarm configuration
- Returns: Aggregated swarm results
- Use case: Large-scale parallel swarm processing

### Resource: reasoning_agents

**create_completion_reasoning_agents** (write)
- Description: Execute a reasoning agent with chain-of-thought capabilities
- Parameters:
  - `task`: The reasoning task
  - Reasoning configuration options
- Returns: Reasoning output with intermediate steps
- Use case: Complex problem-solving requiring step-by-step analysis

**list_types_reasoning_agents** (read)
- Description: List available reasoning agent types
- Returns: Reasoning agent architectures and their characteristics
- Use case: Selecting appropriate reasoning strategies

### Resource: client.rate

**get_limits_client_rate** (read)
- Description: Query rate limits and current usage
- Returns: Rate limit information and usage statistics
- Use case: Monitoring API quota and preventing rate limit violations

### Tools by Operation Type

#### Read Operations (7 tools)
Read operations are safe, idempotent operations that retrieve information without modifying state:

- `get_root_client`
- `check_health`
- `list_available_models`
- `check_available_swarms`
- `get_logs_swarms`
- `list_types_reasoning_agents`
- `get_limits_client_rate`

Plus dynamic tools (when enabled):
- `list_api_endpoints`
- `get_api_endpoint_schema`

#### Write Operations (5 tools)
Write operations execute actions and may modify state or consume resources:

- `run_agent`
- `run_agent_batch`
- `run_swarms`
- `run_swarms_batch`
- `create_completion_reasoning_agents`

Plus dynamic tool (when enabled):
- `invoke_api_endpoint`

## Advanced Usage

### Programmatic Integration

For custom integrations, you can import and configure the server programmatically:

```typescript
import { server, endpoints, init } from "swarms-ts-mcp/server";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

// Initialize the server with all endpoints
init({ server, endpoints });

// Start the server
const transport = new StdioServerTransport();
await server.connect(transport);
```

### Importing Specific Tools

```typescript
import getRootClient from "swarms-ts-mcp/tools/top-level/get-root-client";
import { init } from "swarms-ts-mcp/server";

// Initialize with only specific tools
init({ 
  server: myServer, 
  endpoints: [getRootClient] 
});
```

### Creating Custom Endpoints

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { zodToJsonSchema } from "zod-to-json-schema";
import { z } from "zod";

const myServer = new McpServer({
  name: "custom-swarms-server",
  version: "1.0.0"
});

const myCustomEndpoint = {
  tool: {
    name: 'my_custom_tool',
    description: 'Custom tool for specialized operations',
    inputSchema: zodToJsonSchema(z.object({ 
      query: z.string(),
      options: z.object({
        verbose: z.boolean().optional()
      }).optional()
    })),
  },
  handler: async (client, args) => {
    // Custom implementation
    return { 
      result: "Custom operation completed",
      data: args 
    };
  }
};

init({ 
  server: myServer, 
  endpoints: [myCustomEndpoint] 
});
```

## Error Handling

When integrating with the Swarms MCP server, implement appropriate error handling:

### Common Error Scenarios

1. **Authentication Errors**: Invalid or missing API key
2. **Rate Limiting**: Exceeded API quota
3. **Invalid Parameters**: Malformed requests or missing required fields
4. **Network Issues**: Connectivity problems or timeouts
5. **Resource Unavailability**: Requested models or swarm types not available

### Best Practices for Error Management

- Always validate the presence of the `SWARMS_API_KEY` environment variable
- Implement retry logic with exponential backoff for transient failures
- Monitor rate limits using `get_limits_client_rate` before heavy operations
- Log errors with sufficient context for debugging
- Provide meaningful error messages to end users

## Best Practices


| Best Practice Category           | Recommendation                                                                                                  | Description/Details                                                                                                 |
|----------------------------------|----------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|
| **Batch Operations**             | Use batch endpoints                                                                                            | When processing multiple tasks, prefer batch endpoints to reduce overhead.                                          |
| **Tool Exposure**                | Filter unnecessary tools                                                                                       | Minimize context window usage by exposing only the tools required for your workflow.                                |
| **Rate Limit Monitoring**        | Monitor rate limits                                                                                            | Regularly check your usage with `get_limits_client_rate` to avoid hitting rate limits.                              |
| **Model List Optimization**      | Cache model lists                                                                                              | Store the output of `list_available_models` to prevent repeated, redundant API calls.                               |
| **API Key Security**             | Secure API key storage                                                                                         | Never commit API keys to version control; use secure secrets management.                                            |
| **Environment Management**       | Use environment variables                                                                                      | Manage sensitive information via secure environment variable configuration.                                         |
| **Access Control**               | Limit tool exposure by permission                                                                              | Restrict tool access based on user permissions when possible.                                                       |
| **Audit Logging**                | Utilize audit logging                                                                                          | Use `get_logs_swarms` for security auditing and tracking usage.                                                     |
| **Tool Strategy (Exploration)**  | Start with dynamic tools                                                                                       | Use `--tools=dynamic` during early exploration and development to discover available endpoints.                     |
| **Tool Strategy (Production)**   | Transition to static tool exposure                                                                             | Once requirements are clear, switch to static tool exposure for performance and predictability.                     |
| **Tool Filter Testing**          | Test tool/resource/operation filters                                                                           | Verify your configurations (`--tool`, `--resource`, `--operation`) to ensure only expected endpoints are exposed.   |
| **Client Compatibility**         | Test with target client                                                                                        | Always verify integration and tool compatibility with your specific client setup.                                   |
| **Version Management**           | Pin production versions                                                                                        | Specify the exact package version (e.g., `swarms-ts-mcp@0.1.0-alpha.10`) in production deployments.                 |
| **Health Monitoring**            | Implement health checks                                                                                        | Regularly call `check_health` to ensure server and API availability.                                                |
| **API Reliability**              | Handle API unavailability gracefully                                                                          | Implement graceful degradation strategies for scenarios when the API is down.                                       |
| **Internal Documentation**       | Maintain documentation of exposed tools                                                                        | Keep internal documentation up-to-date on which tools/endpoints are available and why they're exposed.              |


## Client Setup Examples

### Claude Code

Claude Code is a command-line tool that enables Claude to interact with your codebase and execute operations. Here's how to configure the Swarms MCP server for Claude Code.

#### Configuration

Add the Swarms MCP server to your Claude Code configuration file (typically located at `~/.config/claude-code/mcp.json` or similar):

```json
{
  "mcpServers": {
    "swarms_api": {
      "command": "npx",
      "args": ["-y", "swarms-ts-mcp@latest", "--client=claude-code", "--tools=all"],
      "env": {
        "SWARMS_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

#### Recommended Configuration for Claude Code

For optimal performance with Claude Code, consider using a focused set of tools:

```json
{
  "mcpServers": {
    "swarms_api": {
      "command": "npx",
      "args": [
        "-y",
        "swarms-ts-mcp@latest",
        "--client=claude-code",
        "--resource=agent,swarms,reasoning_agents",
        "--capability=tool-name-length=50"
      ],
      "env": {
        "SWARMS_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

#### Usage Example: Running an Agent

Once configured, you can ask Claude Code to execute Swarms agents directly:

```bash
# In Claude Code, you can now use natural language:
# "Run a Swarms agent to analyze this codebase and generate a summary"
```

Claude Code will automatically invoke the `run_agent` tool:

```json
{
  "tool": "run_agent",
  "parameters": {
    "task": "Analyze the codebase structure and generate a comprehensive summary of the architecture, key components, and dependencies.",
    "model": "gpt-4",
    "max_tokens": 2000
  }
}
```

#### Usage Example: Batch Processing

For processing multiple files or tasks:

```bash
# "Process all Python files in this directory using a batch of agents"
```

Claude Code will use the batch endpoint:

```json
{
  "tool": "run_agent_batch",
  "parameters": {
    "tasks": [
      "Analyze file1.py and extract function signatures",
      "Analyze file2.py and identify class definitions",
      "Analyze file3.py and document module exports"
    ],
    "model": "gpt-4"
  }
}
```

#### Usage Example: Multi-Agent Swarm

For complex tasks requiring multiple agents:

```bash
# "Use a sequential swarm to: 1) analyze the code, 2) generate tests, 3) create documentation"
```

```json
{
  "tool": "run_swarms",
  "parameters": {
    "task": "Analyze the codebase, generate comprehensive tests, and create API documentation",
    "swarm_type": "sequential_workflow",
    "model": "gpt-4"
  }
}
```

#### Usage Example: Reasoning Agent

For complex problem-solving tasks:

```bash
# "Use a reasoning agent to debug this error and provide a step-by-step solution"
```

```json
{
  "tool": "create_completion_reasoning_agents",
  "parameters": {
    "task": "Debug the following error: [error message]. Provide a step-by-step analysis and solution.",
    "reasoning_type": "chain_of_thought"
  }
}
```

#### Dynamic Tool Discovery

If you prefer runtime discovery, configure with dynamic tools:

```json
{
  "mcpServers": {
    "swarms_api": {
      "command": "npx",
      "args": [
        "-y",
        "swarms-ts-mcp@latest",
        "--client=claude-code",
        "--tools=dynamic"
      ],
      "env": {
        "SWARMS_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

Then use the discovery tools:

```json
{
  "tool": "list_api_endpoints",
  "parameters": {
    "search": "agent"
  }
}
```

### Claude Chat (Claude Desktop)

Claude Chat (Claude Desktop) provides a conversational interface where Claude can use MCP tools to interact with the Swarms API.

#### Configuration

Add the Swarms MCP server to your Claude Desktop configuration file. On macOS, this is typically located at `~/Library/Application Support/Claude/claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "swarms_api": {
      "command": "npx",
      "args": ["-y", "swarms-ts-mcp@latest", "--client=claude", "--tools=all"],
      "env": {
        "SWARMS_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

#### Recommended Configuration for Claude Chat

For Claude Chat, you may want to expose all tools for maximum flexibility:

```json
{
  "mcpServers": {
    "swarms_api": {
      "command": "npx",
      "args": [
        "-y",
        "swarms-ts-mcp@latest",
        "--client=claude",
        "--tools=all"
      ],
      "env": {
        "SWARMS_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

#### Usage Example: Health Check

Start by verifying the connection:

```
You: "Check if the Swarms API is healthy"
```

Claude will automatically use the health check tool:

```json
{
  "tool": "check_health",
  "parameters": {}
}
```

#### Usage Example: Agent Execution

Execute agents through natural conversation:

```
You: "Run a Swarms agent to summarize the key points from this document"
```

Claude will invoke the agent:

```json
{
  "tool": "run_agent",
  "parameters": {
    "task": "Summarize the key points from the provided document",
    "model": "gpt-4",
    "max_tokens": 1000
  }
}
```

#### Usage Example: Model Discovery

Discover available models before running agents:

```
You: "What models are available in Swarms?"
```

```json
{
  "tool": "list_available_models",
  "parameters": {}
}
```

#### Usage Example: Swarm Orchestration

Use multi-agent swarms for complex workflows:

```
You: "Use a concurrent swarm to analyze these three documents in parallel and provide a comparative analysis"
```

```json
{
  "tool": "run_swarms",
  "parameters": {
    "task": "Analyze three documents in parallel and provide a comparative analysis",
    "swarm_type": "concurrent_workflow",
    "model": "gpt-4"
  }
}
```

#### Usage Example: Rate Limit Monitoring

Check your API usage:

```
You: "What's my current rate limit status?"
```

```json
{
  "tool": "get_limits_client_rate",
  "parameters": {}
}
```

#### Filtered Configuration Example

If you want to limit Claude Chat to read-only operations:

```json
{
  "mcpServers": {
    "swarms_api": {
      "command": "npx",
      "args": [
        "-y",
        "swarms-ts-mcp@latest",
        "--client=claude",
        "--operation=read"
      ],
      "env": {
        "SWARMS_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

This configuration exposes only read operations like `check_health`, `list_available_models`, `check_available_swarms`, and `get_limits_client_rate`, preventing accidental execution of agents or swarms.

## Resources

| Resource                  | Link                                                                                                                              |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| **GitHub Repository**     | [swarms-ts GitHub](https://github.com/The-Swarm-Corporation/swarms-ts/tree/next/packages/mcp-server)                             |
| **npm Package**           | [swarms-ts-mcp on npm](https://www.npmjs.com/package/swarms-ts-mcp)                                                              |
| **Model Context Protocol**| [modelcontextprotocol.io](https://modelcontextprotocol.io)                                                                        |
| **License**               | Apache-2.0                                                                                                                       |

## Version Information

- **Current Version**: 0.1.0-alpha.10
- **Status**: Alpha release
- **Last Updated**: 6 months ago

## Support

For issues, feature requests, or contributions:

- Open an issue on the GitHub repository
- Review existing documentation and examples
- Check the Model Context Protocol specification for general MCP questions
